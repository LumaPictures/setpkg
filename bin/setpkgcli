#!/usr/local/bin/python
import sys
import os

dir = os.path.dirname(os.path.dirname(sys.argv[0]))
sys.path.insert(0, dir)
from setpkg import *
from setpkg import _splitname

import pprint
import argparse

def _get_shell(shell, *args, **kwargs):
    try:
        cls = get_shell_class(shell)
        return cls(*args, **kwargs)
    except KeyError:
        logger.error('unknown shell: %s' % shell)
        sys.exit(1)
  
def result(value):
    sys.__stdout__.write(value + '\n')

# TODO: move this to the Shell class
def status(value):
    sys.__stdout__.write('echo %s;\n' % value)
  
def cli():
    logger.debug(str(sys.argv))

    def list_packages(args):
        if args.active:
            for pkg in list_active_packages(args.packages, args.pid):
                status(pkg)
        else:
            for pkg in list_package_choices(args.packages,
                                                  versions=not args.base,
                                                  aliases=args.aliases):
                status(pkg)

    def doit(func, args):
        set_global = platform.system() == 'Windows' and args.set_global
        shell = _get_shell(args.shell, set_global=set_global)
        logger.debug('setpkg start %s' % (args.packages,))
        try:
            changed = func()
        except PackageError, err:
            sys.stderr.write(str(err) + '\n')
            sys.exit(0)
        except Exception, err:
            import traceback
            logger.error(traceback.format_exc())
            traceback.print_exc(file=sys.stderr)
            sys.exit(0)
        logger.debug('changed variables: %s' % (sorted(changed),))
        for var in changed:
            if var in os.environ:
                cmd = shell.setenv(var, os.environ[var])
            else:
                cmd = shell.unsetenv(var)
            result(cmd)
            logger.debug(cmd)

    def set_packages(args):
        def f():
            added, removed = setpkg(args.packages, force=args.reload, pid=args.pid)
            changed = set([])
            for package in added + removed:
                changed.update(package.environ.keys())
            return sorted(changed)
        doit(f, args)

    def unset_packages(args):
        def f():
            if args.all:
                packages = list_active_packages(pid=args.pid)
            else:
                packages = args.packages
            removed = unsetpkg(packages, pid=args.pid, recurse=args.recurse)
            changed = set([])
            for package in removed:
                changed.update(package.environ.keys())
            return sorted(changed)
        doit(f, args)

    def get_info(args):
        shortname, version = _splitname(args.package[0])
        if args.info_type == 'exe':
            package = get_package(args.package[0])
            status(package.executable)
            return

        if args.aliases:
            package = get_package(args.package[0])
            if version:
                # resolve alias to real version
                version = package.aliases.get(version, version)
                aliases = dict([(a, v) for a,v in package.aliases.items() if v==version])
            else:
                aliases = package.aliases
            width = max(*[len(alias) for alias in sorted(aliases)])
            
            for alias in sorted(aliases): 
                status(alias.ljust(width + 10) + aliases[alias])
            return

        curr_version = current_version(shortname)
        if curr_version is None:
            print "package is not currently set"
            return

        session = Session(pid=args.pid)
        package = session.shelf[shortname]
        pprint.pprint({'vars': package.environ,
                       'version': current_version(shortname),
                       }[args.info_type])

    def alias(args):
        package_files = sorted(walk_package_files())
        shell = _get_shell(args.shell)
        for package_file in package_files:
            try:
                pkg = Package(package_file)
                if pkg.config.has_section('system-aliases'):
                    for alias_suffix, pkg_version in pkg.config.items('system-aliases'):
                        if not pkg_version:
                            pkg_version = alias_suffix
                        result(shell.alias(pkg.name + alias_suffix, 'runpkg %s-%s' % (pkg.name, pkg_version)))
            except PackageError, err:
                pass

    def env(args):
        shell = _get_shell(args.shell)
        var = args.variable[0]
        value = args.value
        if args.action == 'prepend':
            prependenv(var, value)
            cmd = shell.setenv(var, os.environ[var])
        elif args.action == 'pop':
            popenv(var, value)
            val = os.environ[var]
            if val:
                cmd = shell.setenv(var, os.environ[var])
            else:
                cmd = shell.unsetenv(var)
        elif args.action == 'set':
            cmd = shell.setenv(var, value)
        elif args.action == 'unset':
            cmd = shell.unsetenv(var)
        else:
            raise
        result(cmd)

    parser = argparse.ArgumentParser(
        prog='pkg',
        description='Manage environment variables for a software package.')

    parser.add_argument('--pid', metavar='PID', type=str, nargs='?',
                       help='current process id (usually stored in $$)')

    parser.add_argument('--shell', metavar='SHELL', type=str, nargs='?',
                       help='the shell from which this is run. (options are %s)' % ', '.join(shells.keys()))

    subparsers = parser.add_subparsers(help='actions to perform')
    #--- set -----------
    set_parser = subparsers.add_parser('set', help='add packages')

    set_parser.add_argument('packages', metavar='PACKAGE', type=str, nargs='+',
                       help='packages to add or remove')

    set_parser.add_argument('-f', '--force', '--reload', dest='reload', action='store_true',
                       help='set packages even if already set')

    if platform.system() == 'Windows':
        set_parser.add_argument('-g', '--global', dest='set_global', action='store_true',
                           help='set environment for all sessions until system restart')

    set_parser.set_defaults(func=set_packages)

    #--- unset -----------
    unset_parser = subparsers.add_parser('unset', help='remove packages')

    unset_parser.add_argument('packages', metavar='PACKAGE', type=str, nargs='*',
                       help='packages to add or remove')

    unset_parser.add_argument('--all', '-a', dest='all', action='store_true',
                       help='unset all currently active packages')

    unset_parser.add_argument('--recurse', '-r', action='store_true',
                       help='recursively unset dependencies of this package')

    if platform.system() == 'Windows':
        set_parser.add_argument('-g', '--global', dest='set_global', action='store_true',
                           help='unset environment for all sessions until system restart')

    unset_parser.set_defaults(func=unset_packages)

    #--- list -----------
    list_parser = subparsers.add_parser('ls', help='list packages')

    list_parser.add_argument('packages', metavar='PACKAGE', type=str, nargs='?',
                           help='packages to add or remove')

    list_parser.add_argument('--active', dest='active', action='store_true',
                       help='list packages that are currently active')

    list_parser.add_argument('--base', '-b', dest='base', action='store_true',
                       help='list only base packages without version')

    list_parser.add_argument('--aliases', dest='aliases', action='store_true',
                       help='include aliases')

    list_parser.set_defaults(func=list_packages)

    #--- info -----------
    info_parser = subparsers.add_parser('info', help='get information about a package; if no options are provided, --vars is assumed')
    info_parser.add_argument('package', metavar='PACKAGE', type=str, nargs=1,
                             help='package to query')
    info_parser.add_argument('--vars', '-v', dest='info_type',
                             action='store_const', const='vars',
                             help='print what environment variables this package modifies')
    info_parser.add_argument('--exe', '-e', dest='info_type',
                             action='store_const', const='exe',
                             help='get the path to a package executable')
    info_parser.add_argument('--version', dest='info_type',
                             action='store_const', const='version',
                             help='get the current version for a package')
    info_parser.add_argument('--aliases', dest='aliases',
                             action='store_true',
                             help='list aliases for a package or a package version')
    info_parser.set_defaults(func=get_info, info_type='vars')

    #--- aliases -----------
    alias_parser = subparsers.add_parser('system-alias', help='create system aliases for the current shell')
    alias_parser.set_defaults(func=alias)

    #--- env -----------
    env_parser = subparsers.add_parser('env', help='directly modify environment variables')

    env_parser.add_argument('action', metavar='ACTION', type=str, choices=['prepend', 'pop', 'set', 'unset'],
                             help='action to perform')
    env_parser.add_argument('variable', metavar='VAR', type=str, nargs=1,
                             help='variable to modify')
    env_parser.add_argument('value', metavar='VALUE', type=str, nargs='?',
                             help='value to set')
    env_parser.set_defaults(func=env)

    # monkeypatch with a helper that prints to stderr so we don't eval it
    def __call__(self, parser, namespace, values, option_string=None):
        parser.print_help(sys.stderr)
        parser.exit()
    parser._registry_get('action', 'help').__call__ = __call__

    args = parser.parse_args()

    args.func(args)

    logger.info('exiting')


try:
    # only results can go to stdout, so pipe all print statements to stderr
    sys.stdout = sys.stderr
    cli()
finally:
    sys.stdout = sys.__stdout__
